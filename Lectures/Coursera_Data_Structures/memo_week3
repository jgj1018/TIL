#### Introduction (Priority queue)

* Definition : priority queue is an abstract data type supporing the following main operations.
* Insert(p) adds a new element with priority p
* ExtractMax() extracts an element with maximum priority.

#### Naive Implementations of Priority Queues

* inserting an element into a sorted array is expensive because to insert an element into the middle we need to shift all elements to the right of this position by one. So, this makes the running time of the insertion procedure linear. 

*  to keep the list sorted takes already a linear amount of work. And for this reason, inserting into a sorted list still takes a linear amount of work.

|   |Insert|ExtractMax|
|---|---|---|
|Unsorted array/list|O(1)|O(n)|
|Sorted array/list|O(n)|O(1)|
|Binary heap|O(log n)|O(log n)|

#### Binary Trees

* Binary max-heap is a binary tree(each node has zero, one or two children) where the value of each node is at least the values of its children.
* For each edge of the tree, the value of the parent is at least the value of the child.

#### Basic Operation

* SiftUp : for this, we swap the problematic node with its parent until the property is satisfied. Running time: O(tree height)
* Siftdown : for this, we swap the problematic node with larger child until the heap property is satisfied. Running time: O(tree height)
* ChangePriority : change the priority and let the changed element sift up or down depending on whether its priority decreased or increased. Running time: O(tree height)
* Remove : change the priority of the element to infinite, let it sift up and then extract maximum. 

* GetMax works in time O(1), all other operations work in time O(tree height)
* We definitely want a tree to be shallow.


#### Complete Binary Trees

* A binary tree is complete if all its levels are filled except possibly the last one which is filled from left to right.
* A complete binary tree with n nodes has height at most O(log n)
* Which binary heap operations modify the shape of the tree? Only Insert and ExtractMax ( Remove changes the shape by calloing ExtractMax)
* To insert an element, insert it as a leaf in the leftmost vacant position in the last level and let it sift up
* To extract the maximum value, replace the root by the last leaf and let it sift down

##### General setting
* maxSize is the maximum number of elements in the heap. 
* size is the size of the heap
* H[1...maxSize] is an array of length maxSize where the heap occupies the first size elements.

```
Parent(i)
    return i / 2

LeftChild(i)
    return 2i

RightChild(i)
    return 2i + 1
    
ShftUp(i)
    while i > 1 and H(Parent(i)] < H[i]:
        swap H[Parent(i)] and H[i]
        i <- Parent(i)
        
ShftDown(i)
maxIndex <- i
l = LeftChild(i)
if l <= size and H[l] > H[maxIndex]:
    maxIndex <- l
r <- RightChild(i)
if r <= size and H[r] > H[maxIndex]:
    maxIndex <- r
if i != maxIndex:
    swap H[i] and H[maxIndex]
    SiftDown(maxIndex)
    
Insert(p)
if size = maxSize:
    return ERROR
size <- size + 1
H[size] <- p
SiftUp(size)

ExtractMax()
result <- H[1]
H[1] <- H[size]
size <- size - 1
SifyDown(1)
return result

Remove(i)
H[i] <- infinit
SiftUp[i]
ExtractMax()

ChangePriority(i, p)
oldp <- H[i]
H[i] <- p
if p > oldp:
    ShftUp(i)
else:
SiftDown(i)
```

#### Heap Sort

```
HeapSort(A[1...n])
create an empty priority queue
from i from 1 to n:
    Insert(A[i])
for i from n downto 1:
    A[i] <- ExtractMax()
````


* Turn Array into a Heap

```
BuildHeap(A[1...n])
size <- n
for i from [n/2] downto 1:
    SiftDown(i)
```