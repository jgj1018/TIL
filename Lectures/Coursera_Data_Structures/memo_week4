
#### Applications of Hashing

#### IP Addresses


```
Main Loop

log - array of log lines (time, IP)
C - mapping from IPs to counters.
i - first unprocessed log line
j - first line in current 1h window
i = 0
j = 0
C = null
Each second
    UpdateAccessList(log, i, j, C)
    
    
UpdateAccessList(log, i, j, C)
    while log[i].time <= Now():
        C[log[i].IP] = C[log[i].IP] + 1
        i++
    while log[j].time <= Now() - 3600:
        C[log[i].IP] = C[log[i].IP] - 1
        j++
        
AccessedLastHour(IP, C)
    return C[IP] > 0
    
```

#### Direct Addressing

```
int(IP)
    return IP[1]*2^24 + IP[2]*2^16 + IP[3]*2^8 + IP[4]

UpdateAccessList(log, i, j, A)
    while log[i].time <= Now():
        A[int(log[i].IP)] = A[int(log[i].IP)] + 1
        i++
    while log[j].time <= Now() - 3600:
        A[int(log[i].IP)] = A[int(log[i].IP)] - 1
        j++
        
AccessedLastHour(IP)
    return A[int(IP)] > 0
    
```

* UpdateAccessList is O(1) per log line
* AccessLastHour is O(1)
* Bue need 2^32 memory even for few IPs.
* IPv6: 2^128 won't fit in memory.
* In general: O(N) memory 


#### List-based Mapping

- Direct addressing requires too much memory
- Let's store only active IPs.
- Store them in a list sorted by time of access

```
UpdateAccessList(log, i, L)
while log[i].time <= Now():
    L.Append(log[i])
    i = i + 1
while L.Top().time <= Now - 3600:
    L.pop()
    
AccessLastHour(IP, L)
    return L.FindByIP(IP) != null

AccessCountLastHour(IP, L)
    return L.CountIP(IP)
```

- AccessLastHour, AccessCountLastHour are still O(n)


#### Hash Functions

- Definition: For any set of objects S and any integer m > 0, a function h : S -> {0, 1 ..., M-1} is called a hash function.
- m is called the cardinality of hash function h.

- h should be fast to compute
- Different values for different objects.
- Direct addressing with O(m) memory.
- Want to small cardinality m
- Impossible to have all different values if number of objects |S| is more than m.\
- When h(o1) = h(o2) and o1 != o2, this is a collision.


#### Chaining Scheme

- Map: Store mapping from objects to other objects.
- Definition: Map from S to V is a data structure with methods HasKey(O), get(O), Set(O, v) where O (= S, v (= V.

#### Chaining Implementation and Analysis

```
HasKey(O)
    l = A[h(O)]
    for (01, v1) in L:
        if O1 == O:
            return true
    return false


Get(O)
    l = A[h(O)]
    for (01, v1) in L:
        if O1 == O:
            return v1
    return n/a
    
Set(O, v)
    L = A[h(O}]
    for p in L:
        if p.O == O:
            p.v = v
            return
    L.Append(O,v)
          
```


#### Hash Table


```
Find(O)
L = A[h(O)]
    for  O1 in L:
        if O1 == O:
            return true
    return false
    
Add(O)
    L = A[h(O)]
        for O1 in L:
            If O1 == O:
                return
        L.Append(O)
  
Remove(O)
    if not Find(O):
        return
    L = A[h(O)]
    L.Erase(O)
````

- Hash table Definition : An implementation of a set or a map using hashing is called a hash table
- Chaining is a technique to implement a hash table
- Memory consumption is O(n + m)
- Operations work in time O(c + 1)


####

- Phone Book Problem
- Direct Addressi