#### Chapter 0A 앞단 성능의 중요성

* 현실적으로 대부분의 웹 페이지는 최종 사용자의 반응 시간(브라우저 반응 시간) 중 HTML 문서를 웹 서버로부터 다운로드받는 데 소요되는 시간이 10% ~ 20%도 채 되지 않는다. (...중략...) 브라우저는 HTML을 분석하고 페이지 안에 포함되어 있는 이미지, 스크립트, 스타일시트와 같은 HTML 구성요소를 다운받기 시작한다. (...중략...) HTTP 트래픽을 보는 방법을 통하여 최종 사용자 응답 시간의 80%는 페이지 안의 구성요소를 다운받는 데 소비되는 것을 알 수 있었다.


* HTTP 문서를 요청하기 위한 HTTP 요청 바로 다음에 오는 빈 공간을 볼 수 있다. 이것은 브라우저가 HTML, 자바스크립트, CSS를 파싱하고 캐시로부터 이런 구성요소를 불러오는(읽는) 시간이다.


* 스크립트는동시 다발적으로 요청하지 않는다. 그 이유는 스크립트가 다운로드 중인 경우에 브라우저는 대부분 추가적인 HTTP 요청을 막기 때문이다.

#### Chapter 0B HTTP의 이해

* 조건부 GET 요청 : 브라우저 캐시에는 구성요소의 복사본이 있지만 그 구성요소가 유효한지 확실하지 않을 경우 조건부 GET 요청을 보낸다. (...) 일반적으로 캐시된 구성요소의 유효성은 최종 수정 날짜로 판단된다. 브라우저는 구성요소가 마지막으로 언제 수정되었는지를 응답 헤더의 Last-Modified 항목을 통해 알 수 있다. 브라우저는 If-Modified-Since라는 헤더 속성을 통해서 서버로 최종 수정 날짜를 보내게 된다. (...) 구성요소가 지정한 날짜로부터 수정되지 않았다면 서버는 "304 Not Modified"라는 상태 코드를 반환하게 된다.


* 조건부 GET 요청과 304 응답은 페이지를 더 빠르게 로드할 수 있게 도와주지만 유효성을 확인하려면 여전히 클라이언트과 서버간의 요청/응답의 왕복이 필요하다. 하지만 헤더 만료기한(Expires)은 서버로 접근하여 구성요소의 유효성을 확인하는 작업을 생략할 수 있게 해주고 브라우저는 캐시의 복사본이 아직 유효한지 바로 알 수 있게 해 준다.


* 페이지 안의 대부분의 이미지는 공통된 이미지 서버에 요청을 보내게 된다. 지속성 있는 연결(Persistent connections)은 이렇게 같은 서버에 여러 개의 소켓 연결을 맺는 비효율 문제를 해결하기 위해 나왔다. 즉 하나의 연결 안에 여러 개의 요청을 보내는 것이다. 브라우저와 서버는 헤더의 Connection 속성에 Keep-Alive값을 지정할 수 있다. (...) 이것은 HTTPS에서 더 중요한데. 보안 소켓 연결은 더 많은 시간을 필요로 하기 때문이다.

#### 규칙 1 HTTP 요청을 줄여라
#### 규칙 2 콘텐츠 전송 네트워크를 이용하라

* 구성요소가 저장되어 있는 웹서버가 사용자와 가깝다면 여러 개의 HTTP 요청 시간이 짧아질 것이다. (...) CDN(콘텐츠 전송 네트워크)은 사용자에게 효율적으로 콘텐츠를 전달하기 위하여 여러 지역에 웹 서버를 분산시켜 놓는 기술이다. (...) 응답 시간을 줄이는 것 외에도 CDN 서비스는 백업, 저장 용량의 확대, 캐싱과 같은 기능을 포함한다. (...) CDN에 의존하류경우의 단점은 다른 웹 사이트의 트래픽에 내 사이트가 영향을 받을 수 있다는 것이다. CDN은 이미지, 스크립트, 스타일시트, 플래시와 같은 정적 콘텐츠를 전달할 때 이용 된다. (...) 정적 파일은 호스트에서 쉽게 이용될 수 있고 의존적인 요소도 거의 갖고 있지 않다. 그렇기 때문에 CDN을 쉽게 도입할 수 있고 지리적을 ㅗ분산된 사용자의 응답시간을 더 쉽게 개선할 수 있다.

