## 인프라를 지탱하는 기본 이론

### 직렬/병렬

- 특정 기간 내에 하나의 CPU로 처리할 수 있는 양에는 한계가 있지만, 여러 개의 CPU를 배치하면 처리량을 늘릴 수 있다. 단 다수의 CPU를 이용할 수 있는 처리여야 한다는 전제 조건이 있다. 분담해서 병렬화할 수 없는 처리는 CPU 코어를 아무리 늘려도 효과가 없다. 이때는 CPU 클럭 주파수를 올리는 방법, 즉 직렬 처리 속도를 올리면 고속처리가 가능하다.

- 직렬 처리로 속도를 올리는 데는 한계가 있다.
- 병렬화를 통해 속도는 빨라지지 않지만 단위 시간당 처리량을 늘릴 수 있다
- 병렬화할 때는 일을 분담해서 처리를한 후 다시 집약될 때 오버헤드가 걸린다. 그러므로 이 오버헤드를 감안하더라도 효과가 있을 경우에 병렬화를 한다.
- 프로세스나 스레드 수를 조정할 때는 CPU 코어 수도 함께 고려해야 한다. 편의점 계산대가 하나밖에 없다면 계산대를 담당하는 사람들이 여러 명이라도 소용이 없는 것과 마찬가지다. 
- 병렬(parallel)과 병행(concurrent)은 비슷해보이지만 의미가 다르다.
- 동시에 복수의 처리를 실행하는 것이 병렬이고, 복수의 처리가 실행 상태에 있는 것을 병행이라고 한다. 즉, 병행은 병렬을 내포하는 개념이다. 쉽게 말하면 한 명이 여러 일을 동시에 하는 것은 병행이지만 병렬은 아니다. 여러 사람이 동시에 여러 일을 하는 것은 병렬이다.

### 동기/비동기

- 누군가에게 일을 부탁하고 그 일이 끝나기까지 잠자코 기다리는 것이 동기이고, '끝나고 말해'라고 하고 다른 일을 하는 것이 비동기이다. 즉 비동기에서는 처리를 병행해서 진행할 수 있다.
- 비동기 I/O는 대량의 I/O를 효율적으로 처리해야하는 DBMS에 적합하다고 할 수 있다. 공유 메모리에 있는 다수의 데이터를 프로세스가 HDD에 기록하는 경우, 비동기 I/O라면 하나의 I/O가 끝나기까지 기다리지 않고 다음 I/O를 발행할 수 있기 때문에 저장소 성능을 충분히 활용할 수 있다. (...)이와 같이 DBMS  에서는 I/O 병렬화 수단으로 비동기 I/O를 사용할 수 있다.
- 나는 비동기의 본질이 병렬이라고 생각한다.
- 비동기의 주의할 점 : 비동기로 요구한 처리가 끝나지 않은 상태에서 다음 처리를 진행해도 문제가 없는가.
- 비동기의 주의할 점 2: 비동기로 요구한 처리가 끝났는지 확인할 필요가 있는가.

### 큐

- CPU를 기다리고 있는 프로세스 행렬을 run-queue라고 한다. 런큐에 쌓인 프로세스 수를 코어 수로 나누어서 1이라면 문제 없다는 게 일반적이다.

### 배타적 제어

- 컴퓨터 세계에서도 직렬 처리에서는 배타적 제어가 필요 없지만 병렬 처리에서는 필요하다.
- 복수의 처리가 공유 자원(CPU, 메모리, 디스크)에 동시에 액세스(주로 갱신)하면 불일치가 발생할 수 있기 때문에 배타적 제어로 보호해 주어야 한다.
- 배타적 제어에서는 특정 처리가 공유 자원을 이용하고 있는 동안 다른 처리가 이용할 수 없게 해서 불일치가 발생하지 않도록 한다.

### 상태 저장/상태 비저장

- 상태를 가진다는 것은 과거에 부여한 정보를 저장해서 계속 활용할 수 있다는 것을 의미한다. 상태를 가지고 있지 않다면 과거 정보를 알 수 없다.
- 상태 저장은 상태를 고려하기 때문에 복잡한 처리가 가능하지만, 시스템 복잡성이 커진다.
- 상태 비저장은 상태를 고려하지 않기 때문에 간단하며, 성능이나 안정성 측면에서 우수하다.
- HTTP는 기본적으로 상태 비저장방식이;지만 위와 같이 상태를 저장해야 하는 경우가 있다(로그인) HTTP에서는 세션(session)이라는 개념을 사용해서 이 구조를 구현하고 있다.

### 가변 길이/고정 길이

- 가변 길이는 공간을 유용하게 활용할 수 있지만 성능 면에서 불안정하다
- 고정 길이는 쓸 데 없는 공간이 생기지만 성능 면에서는 안정적이다.

### 탐색 알고리즘(해시/트리 등)

- B 트리 인덱스가 DBMS에서 자주 사용되는 것은, 트리 구조 계층이 깊어지지 않도록 디스크 I/O를 최소한으로 제어하기 때문이다. 반대로 메모리에 모든 데이터를 두는 인메모리 DB에서는 디스크 I/O를 신경 쓸 필요가 없기 때문에 디스크에 데이터가 저장된다는 것을 전제로 개발된 DBMS와는 다른 접근 방법이 필요하다.

- 해시 테이블은 (...) 등호 검색 시의 최고의 데이터 구조라고 할 수 있지만 범위 검색이 약하다는 문제가 있다. DBMS 인덱스 관점에서 보면 B 트리 인덱스가 만능형이라면 해시 인덱스는 전문 분야에 특화된 것이라 할 수 있다.

## 인프라를 지탱하는 응용 이론

### 캐시

- 일부 데이터를 데이터 출력 위치와 가까운 지점에 일시적으로 저장한다.
- 데이터 재사용을 전제로 한다.

- 적합한 시스템 : 참조 빈도가 높은 데이터. 
- 적합한 시스템 : 캐시의 데이터가 손실돼도 문제가 없는 시스템 : 예를 들어 스트리밍 데이터 등은 갱신이 없기 때문에 캐시에 장애가 발생해도 원데이터를 다시 캐시에 배치하기만 하면 복원이 가능하다. 이런 읽기 전용 데이터에 적합하다.
- 부적합한 시스템: 데이터 갱신 빈도가 높은 시스템. 데이터 빈도가 빈번하게 발생하는 경우는 갱신 시마다 캐시해야 해서 바로 엑세스하는 경우와 차이가 없다. 따라서 캐시에 의한 성능 향상을 기대할 수 없다.
- 부적합한 시스템: 대량의 데이터에 엑세스하는 시스템. 데이터 액세스 시에 수백 GB 이상의 큰 데이터를 참조하는 경우 캐시 크키도 커지며 캐시에 배치하기까지도 많은 시간이 걸린다.
- 데이터가 실제 데이터와 캐시라는 이중 구조로 저장되기 때문에, 리소스 소비가 늘어난다. 설계 시에는 어떤 데이터를 캐시하는 것이 효과적인지를 검토해야 한다.
- 캐시 계층이 늘어나기 때문에 시스템 성능 문제나 데이터 불일치기 문제가 발생한 경우는 문제 발생을 야기한 용의자가 늘어난다.
- 캐시의 데이터가 손실되는 경우를 대비해서 복구 순서를 설계 시에 확립해야 한다.
- 갱신 데이터(쓰기 데이터)를 캐시할 때 캐시가 여러 개 있으면 갱신된 최신 데이터를 서로 뺏으려는 상태가 발생하지 않도록 주의해야 한다.

### 끼어들기

- 브라우저가 웹사이트에 접속하면 서버의 NIC에 이더넷 프레임이 도착한다. 이더넷 프레임이 도착하면 NIC를 통해 CPU에 끼어들기가 발생하고, CPU를 사용하고 있던 프로세스 정보가 메모리에 저장된 후 일시적으로 CPU를 빼내서 데이터를 수신한다. 끝나면 중단했던 프로세스 처리가 재개된다. 이와 같이 입출력 장치가 CPU에게 통지하는 끼어들기를 하드웨어 끼어들기라고 한다.
- 끼어들기는 어떤 일이 발생하면 연락하는 '이벤트 주도' 구조이다.
- CPU 동작 속도에 비해 입출력 장치의 상태 갱신 빈도가 높지 않다. 따라서 풀링보다 끼어들기를 이용해서 제어하는 것이 효율적이기 때문에 끼어들기를 채택하고 있다.

### 폴링

- 폴링(polling) 이란 정기적으로 질의하는 것을 가리킨다.
- 질의 방향이 단방향이다
- 질의는 일정 간격을 따라 정기적으로 발생한다.
- 적합한 처리: 일정 간격으로 처리를 실행하면 좋은 처리, 감시
- 부적합한 처리: 상태가 아닌 입력 내용에 따라 실행 내용을 변경하는 처리. 예를 들어 키보드는 키를 누른 '상태'에 따라 처리 내용이 달라지는 것이 아니라 입력 한 내용에 따라 처리가 결정되기 때문에 폴링으로 구현하는 것은 적합하지 않다
- 네트워크를 경유한 폴링일 때는 처리 지연 시간을 줄이기 위해 폴링 간격을 너무 짧게 잡으면 트래픽 양이 증가하므로 주의가 필요하다. 또한 서버의 리소스 소비도 늘어난다.

### 핑퐁

- I/O 크기가 작을 때는 플록 크기를 작게, I/O 크기가 크면 블록 크기를 크게 해야 I/O효율이 좋아진다.
- 이것은 오라클 DB에 해당되는 얘기로, 그 아래 계층도 의식할 필요가 있다. 블록 크기 8KB의 DB파일을 ext3 파일 시스템에 저장한다고 가정해보자. ext3 파일 시스템의 블록 크기가 4KB라고 하면 OS 계층에서는 두 개 블록으로 분할된다.
- 파일 시스템의 블록 크기가 7KB이고 오라클 DB의 블록 크기가 8KB라고 가정하면, 오라클 DB가 1블록(8KB)을 읽으면 디스크에서 14KB(7KB X 2)를 읽어서 그 중 6KB는 사용하지 않는다.
- 입출력 시에 MTU 크기가 같다면 그대로 송신되지만 경로 도중에 있는 라우터의 MTU 크기가 작게 설정돼 있으면 웹 서버가 송신하는 패킷이 경로 도중에 더 작게 분할돼서 오버헤드가 발생하고 이는 성능 저하로 연결될 수 있다.
- 중요한 것은 모든 통신 경로의 파라미터를 적절하게 설정해야 한다는 것이다. 일부 설정을 변경하더라도 경로 상에 모든 통신이 제대로 설정돼 있지 않으면 효과를 볼 수 없다.

### 저널링

- 저널(journal)은 트랜잭션이나 매일 갱신되는 데이터의 변경 이력을 가리킨다. 저널을 남겨두는 것을 저널링(journaling)이라고 한다.
- 데이터 자체가 아닌 처리(트랜잭션) 내용을 기억한다
- 데이터 일관성이나 일치성이 확보되면 필요 없어진다.
- 데이터 복구시 롤백, 롤포워드에 이용된다.
- 장점1: 시스템 장애 시 복구가 빠르다.
- 장점2: 데이터 복제보다도 적은 리소스를 소비해서 데이터를 보호할 수 있다
- 이와 같이 저널링은 데이터 안전성을 높이기 위한 목적으로 사용된다.
- 적합한 시스템: 데이터 갱신이 발생하는 시스템
- 부적합한 시스템: 데이터 안정성보다 성능을 요구하는 시스템. 저널링을 하면 기록 처리 시 오버헤드가 발생하기 때문에 성능을 중시하는 시스템이라면 이 오버헤드를 줄일 방법을 검토해야 한다. 예를 들어 캐시 서버 등 실제 데이터가 다른 장소에 있는 서버에서는 부적합하다.
- 저널은 복구 시에 필요하기 때문에 일반적으로 데이터보다 먼저 기록된다.
- 저널은 트랜잭션 단위로 일치성을 보증하기 때문에 트랜잭션 도중에 장애가 발생하면 종료되지 않은 트랜잭션은 파괴 된다.
- 하드 웨어 장애 시의 동작 (...) 기록이 끝나지 않은 상태의 내용이 그대로 노출되면 다른 프로세스는 해당 파일이 기록 도중에 실패한 것인지 아니면 기록이 끝난 파일인지를 판단할 수 없어서 불일치가 발생할 수 있다. 이것을 보중하기 위한 구조로 하나는 저널링이고, 또 다른 한 가지는 copy-on-write(COW)라는 구조이다.
- 저널링처럼 증감 정보를 작성하지 않고 파일 갱신은 모두 신규영역에서 한다. 그리고 이것이 모두 완료된 시점에 파일이 참조할 위치를 이전 영역에서 신규 영역으로 순식간에 교체하는 방시;ㄱ이다.
- 단점은 원 데이터가 그대로 남아 있는 상태에서 신규 데이터를 기록하기 때문에 데이터 영역이 최대 두 배가 필요하다는 점이다. 하지만 HDD용량이 최근 증가하고 있기 때문에 이후에는 크게 문제가 되지 않을 수 있다.

### 압축

- 디지털 데이터 압축의 기본은 '중복 패턴 인식'과 그것을 '변경'하는 것이다.
- zip 파일로 압축할 때 어떤 파일은 크기가 작아지지만 어떤 파일은 그대로인 것을 보면서 신기하게 생각한 적이 있을 것이다. 이것은 같은 패턴이 어느 정도 있느냐에 따라 압축률이 달라지기 때문이다. 같은 패턴이 많을수록 압축률이 높아진다.
- 압축의 장점은 크기를 줄이는 것, 단점은 처리시간이 걸린다는 것
- 압축한 데이터를 원래대로 복원할 수 있는 가역압축과 이미지나 음성데이터 등에 있는 사람이 인식할 수 없는 부분을 생략하는 비가역 압축이 있다.

## 시스템을 연결하는 네트워크 구조

### TCP/IP를 이용하고 있는 현재의 네트워크

- TCP를 반드시 사용해야 하는 것은 아니며, IP는 통신 상태 지정 시에 IP 주소를 이용하기 때문에 반드시 필요하다고 할 수 있다.
- HTTP 통신 데이터를 상대방에게 보내기 위해 TCP에 데이터를 건네지만, 여기부터 이더넷 계층까지는 OS 커널이 담당한다. 커널 내에서 TCP, IP, 이더넷을 담당하는 기능이 필요한 정보를 데이터에 부여해서 최종적으로 이더넷 프레임이 생성된다. 이것이 NIC에 전달돼서 이더넷 케이블 등을 통해 인접 노드를 경유해서 최종 위치까지 전달된다.

### (레이어 7) 애플리케이션 계층의 프로토콜 HTTP

- 요청 시 중요한 것은 서버에 던지는 명령이다. 예를 들어 GET은 파일 요구이고, POST는 데이터를 전송한다는 의미이다.
- 애플리케이션 계층 프로토콜은 필요한 데이터를 소켓에 기록만 하며 통신은 모두 TCP/IP에 위임한다.
- 애플리케이션 프로세스가 네트워크 통신을 하는 경우 커널에 TCP/IP로 통신을 하고 싶으니까 상대방 애플리케이션과 통신할 수 있는 회선을 열어줘라고 의뢰한다. 의뢰방법은 시스템 콜이다. 이때 접속 대상 서버의 IP주소와 TCP 포트의 두 가지 정보가 필요하다. (...) 의뢰를 받은 커널은 소켓을 만들어 준다. 소켓을 만든 것뿐이므로 데이터를 보내기 위해 구멍을 연 것이다. 이번에는 TCP를 사용하기 때문에 TCP를 사용한다는 것과 IP 주소 및 포트 번호 정보를 시스템 콜 경유로 커널에 전달하면 접속 대상 서버와의 연결이 생성된다. 이때 상대방 서버에서도 소켓이 만들어지며 상대 서버와의 사이에 가상경로(버추얼 서킷)가 생성된다.

### (레이어4)  전송계층 프로토콜 TCP

- TCP의 역할을 간단히 말하면 '애플리케이션이 보낸 데이터를 그 형태 그대로 상대방에게 확실하게 전달하는 것이다. 단 가능한 한 주변에 민폐를 끼치지 않는다.'
- TCP가 담당하는 것은 어디까지나 서버가 송신할 때와 서버가 수신한 후 애플리케이션에게 전달할 때로, 상대 서버까지 전송하는 부분은 하위 계층인 IP에 모ㅓ두 위임한다. 물론 TCP에 의존하지 않고 IP만으로도 통신할 수 있지만, IP에는 모든 데이터가 상대방에게 확실히 전달됐는지 확인하는 기능이나 도착한 ㅅ누서를 확인하는 기능 등이 없다.

- TCP가 하는 기능은 많지만 중요한 기능 : 포트 번호를 이용해서 데이터 전송, 연결 생성, 데이터 보증과 재전송 제어, 흐름 제어와 폭주 제어
- 소켓에 기록된 애플리케이션 데이터는 소켓의 큐를 경유해서 소켓 버퍼라 불리는 메모리 영역에서 처리된다. 소켓 버퍼는 소켓별로 준비된 전용 메모리 영역으로, 이후 계속되는 IP나 이더넷까지의 일련의 처리도 소켓 버퍼 내에서 이루어진다.
- TCP 통신을 시작할 때 상대 서버에 포트 번호와 연결을 열어달라고 부탁만 할 뿐 다른 특별한 일은 하지 않는다. 데이터 전송 자체도 IP에 위임하기 때문에 실제 물리적인 경로가 막히거나 통신 상대 서버가 갑작스런 장애로 전원이 꺼져도 가상적인 경로인 TCP 연결이 끊어지진 않는다. 이런 상태에서는 데이터가 전달되진 않지만 기본적으로 애플리케이션이 OS에게 연결 절단을 의뢰하거나 통신 대상이 에러를 보내오지 않는 이상 TCP 연결 자체가 유지되기 때문에 주의가 필요하다.

- 먼저 데이터 손실을 방지하는 기능에 대해 알아보자. 이것은 확인 응답과 재전송에 의해 구현된다. 수신 측에 TCP 세그먼트가 도착하면 수신 측은 송신 측에 도착했다는 것을 알린다. 이때 반환하는 것은 ACK라고 하며 TCP 헤더에 ACK 관련 정보를 넣은 TCP 세그먼트를 반환한다. 송신 측은 ACK가 돌아오는 것을 보고 전송한 세그먼트가 무사히 도착했다는 것을 알 수 있다. ACK가 돌아오지 않으면 전송한 TCP 세그먼트가 어떤 이유로 사라졌을 가능성이 있다. 이 때문에 언제든지 재전송이 가능하도록 전송이 끝난 TCP 세그먼트라도 ACK가 돌아오기 전까진 소켓 버퍼에 남겨 둘 필요가 있다.

- ACK가 오지 않으면 재전송한다고 말했지만 어느 시점에 재전송을 하는 것일까? 첫 번째는 타임아웃이다 (...) 또 다른 기준(...) 시퀸스 번호 2921의 TCP 세그먼트가 경로 도중에서 사라졌다. 수신 측에는 그 다음 TCP 세그먼트가 도착하지만 도중에 사라진 세그먼트를 계속 요구하기 때문에 ACK에서는시퀸스 번호 2921을 보내달라고 계속 응답한다. 그리고 송신 측에는 같은 ACK가 계속 돌아오지만 한 번 받은 ACK 번호와 같은 것이 중복돼서 도착한 경우 그 번호에 해당하는 TCP 세그먼트가 도착하지 않았다고 간주하고 재전송한다. 이것을 중복 ACK라고 한다. 1회 중복 ACK로 바로 재전송하지 않고 3회까지 기다리는 것은 가끔 해당 세그먼트만 경로 도중에 지연돼서 도착 순서가 바뀔 수 있기 때문이다.

- TCP는 어느 정도 세그먼트 수라면 ACK를 기다리지 않고 전송하는 윈도우라는 개념을 가지고 있으며 ACK를 기다리지 않고 전송가능한 데이터 크기를 윈도우 크기라고 한다. 

### (레이어 3) 네트워크 게층의 프로토콜 IP

- IP의 역할은 '지정한 대상 서버까진 전달받은 데이터를 전해주는 것'
- IP에서는 반드시 전달되는 것을 보장하지 않는다.
- IP 주소를 이용해서 최종 목적지에 데이터 전송
- 라우팅(routing)
- TCP 세그먼트에 IP 헤더를 붙여서 IP 패킷을 생성한다. 대상 서버까지는 이 IP 패킷 형태로 네트워크를 경유해서 도달한다. IP 헤더에는 최종 목적지 서버의 IP 주소가 기록된다.
- IP 주소는 네트워크부와 호스트부로 나뉜다. 네트워크부는 어떤 네트워크인지를 가리키고, 호스트부는 해당 네트워크 내에 있는 컴퓨터(소유자)를 가리킨다.
- IP 주소 중 호스트부의 비트가 모두 0인 것을 네트워크 주소, 모두 1인것을 브로드캐스트 주소라고 한다.
- 브로드캐스트 주소로 보낸 패킷은 같은 네트워크의 모든 호스트에 전달된다.
- IP를 이용한 전솔은 주변을 신뢰해야만 성립되는 것이다.
- 라우팅 테이들에 오류가 있으면 네트워크에서 패킷이 계속 순회하게 돼서 곤란한 상태에 이른다. 이런 상태를 방지하기 위해 IP 헤더는 TTL(Time to live)라는 생존시간 정보를 가지고 있다.
- 본래 TCP 헤더에도 체크섬이 있으며 이 체크섬 계산으로 IP 주소 부분을 포함한 일치성을 확인하고 있다. 이 때문에 IPv6부터는 체크섬이 깔끔하게 제외됐다. 이외에도 가변 길이가 허용됐던 IPv4와 달리 IPv6 헤더는 40바이트 고정 길이를 사용하는 등 라우터가 처리해야 할 부분을 줄이고 있다.

### (레이어 2) 데이터 링크 계층의 프로토콜 이더넷

- IP는 IP 주소를 사용해서 여러 네트워크를 거쳐 데이터를 전송할 수 잇지만, 이더넷은 동일 네트워크 내, 즉 자신이 포함된 링크 내에서만 데이터를 전송할 수 있다. 이때 사용되는 주소가 MAC(맥) 주소다.
- IP 계층에서 라우팅 테이블을 확인하기 때문에 어떤 링크(NIC)가 패킷을 보낼지는 정해져 있다. 최종적인 통신 상태가 동일 네트워크 내에 있으면 해당 서버에 직접 전송하지만 다른 네트워크에 있으면 기본 게이트웨이에 패킷을 보내야 한다. 여기서는 MAC주소라 불리는 링크 계층 주소를 사용해서 첫 번째 목적지로 보낸다.
- IP 패킷에 이더넷 헤더와 푸터를 붙여서 이더넷 프레임을 만든다. 헤더에는 링크 계층 주소인 MAC 주소가 기록돼 있다. 목적지 IP 주소에 따라 경로표(라우팅 테이블)을 이용해서 어떤 NIC에서 보내야 할지를 결정한다.
- IP 주소에 라우팅 테이블이 있었던 것처럼 MAC 주소에는 ARP 테이블(MAC 테이블)이라 불리는 표가 있다. 동일 링크 내의 노드에 대해서 IP 주소 A에 대응하는 것은 MAC 주소 B다와 같은 형식으로 IP 주소와 MAC 주소의 대응 관계를 기록한 표이다. 이렇게 인접한 장비의 MAC 주소를 헤더에 기록한 후 최종적으로는 OS가 버스를 통해 NIC에게 전달한다. NIC는 이것을 다시 네트워크에 전송한다.
- MTU는 네트워크 상의 모든 경로에서 동일한 것이 아니다. 경로 도중에 MTU가 작아서 1패킷이 MTU에 들어가지 않으면 필요에 따라 경로 도중에 네트워크 장비에서 패킷이 분할된다. 경로 도중에서의 패킷 분할은 설정이나 환경에 따라서는 실시되지 않는 경우도 있는데, 이 경우에는 안타깝게도 패킷이 파괴된다. (...) 경로에서 패킷 분할을 하는 것은 IPv4의 기능으로 IPv6에서는 경로 상의 패킷 분할 기능이 폐지됐다.
- L2 스위치에서는 이더넷 헤더를 보고 목적지를 정하지만 L3 스위치나 라우터에서는 IP헤더까지 확인해서 목적지를 결정한다.
- 서버 A가 서버 C로 IP 패킷을 보내는 경우를 보자. 서버 C는 다른 네트워크 서버이기 때문에 먼저 기본 게이트웨이로 보내서 IP라우팅을 이용해서 패킷을 전달해야 한다. 이 세 개의 네트워크(링크)를 경유하게 되지만 IP 패킷은 각각 다른 이더넷 프레임에 저장돼서 전달된다.
- NIC로 프레임이 도착하면 일단은 NIC 수신 큐에 저장해서 OS 끼어들기나 OS 폴링을 이용해서 커널 내에 프레임을 복사한다. 그리고 이더넷 헤더와 푸터를 제거하고 IP패킷을 꺼낸다. 여기서 IP 주소를 확인해서 자신에게 보낸 패킷이 맞는지 확인한다. 자신에게 보낸 패킷이 맞다면 IP 헤더를 제거하고 TCP 세그먼트를 꺼낸다. TCP 포트 번호를 확인해서 포트 번호에 대응하는 소켓에 데이터를 전달한다. TCP는 데이터 보증을 하기 때문에 없어진 세그먼트가 있어서도 안되고 순서가 틀려서도 안된다. 이 때문에 데이터 재구성을 위한 세그먼트가 모두 도착하기까지 버퍼 내에서 기다리는 경우가 있다. 마지막으로 TCP 헤더를 제거하고 안에 있는 애플리케이션 데이터를 재구성하고 이것을 소켓을 통해 애플리케이션에게 전달한다.