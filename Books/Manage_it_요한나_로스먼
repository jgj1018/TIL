
## 1. 프로젝트 시작하기

- 프로젝트: 새로운 제품이나 서비스를 만들기 위해 완전히 새롭게 시도되는 일 또는 체계적인 프로세스로서, 완성된 것을 인도하면 끝난다. 프로젝트에는 위험이 반드시 존재하고 한정된 자원때문에 일반적으로 제한을 받는다.

- 프로젝트 관리자는 위험과 자원을 관리합니다.

- 프로젝트 관리자: '완료'란 무엇인지 명확하게 정의하고, 완료란 무엇인지 의사소통하면서 팀을 완료로 이끄는 사람. 여기서 말하는 '완료'는 회사에서 제품을 개발하는 목적을 달성하고 고객이 제품을 사용하면서 만족하는 것입니다.

- 단 하나의 견인인자와 제한인자, 그리고 4개의 변동인자가 있을 때가 이상적입니다. 견인인자가 1개, 제한인자는 2개, 변동인자가 3개라면 여전히 성공할 수 있습니다. 견인인자와 제한인자가 많아질수록 프로젝트에는 지나치게 제약이 많아집니다.

- '왜'라는 질문을 적게 할수록 비즈니스 요구를 더욱 잘 파악할 수 있습니다. '왜'라는 질문은 다른 사람을 방어적으로 만들기 쉽습니다. '어떻게'란 질문도 삼가야 합니다. '어떻게'란 질문은 후원자에게 시스템을 설계해달라고 부탁하는 것처럼 들립니다.

#### 프로젝트 헌장

- 비전: 이 프로젝트를 하는 이유가 무엇인가?
- 목표: 프로젝트의 목표는 여러분이 프로젝트에서 완수하고 싶은 것이지만, 고객이나 후원자가 기대하는 것은 아닐 수도 있습니다.
- 성공기준: 성공기준이란 프로젝트가 끝났을 때 고객이 제품을 사용해서 무엇을 할 수 있을지를 정의한 것입니다.
- 프로젝트 헌장을 반복해서 수정할 것을 예상하세요.

## 2. 프로젝트 계획하기

- 게획하기와 일정잡기는 서로 다른 활동입니다. 계획하기(planning)란 출시 기준을 포함한 프로젝트 계획을 작성하는 것입니다. 일정잡기(scheduling)란 업무의 윤곽을 잡고 순서를 부여하는 것입니다. 

- 계획은 완벽할 수 없습니다. 여러분이 세우는 계획은 성공할 가능성이 있고 프로젝트를 시작하기에 적당한 정도면 충분합니다.

- 프로젝트에서 특정한 기능이 언제 완성될지 예측해야 한다면 처음 몇 주 동안 처음으로 예측하는 데 시간을 쓰고, 다음 몇 주 동안 이 예측을 갱신합니다. 8주나 12주가 될 때쯤, 어떤 기능이 언제 완성될지 감을 얻습니다.

- 계획을 세우고 데이터를 얻은 다음 다시 계획을 세웁니다.

- 프로젝트의 기간에 여유가 있더라도 '정확한' 계획을 세우려고 지나치게 많은 시간을 쏟으면 시간 압박에 시달리게 됩니다.

- 경험적인 계획하기란 계획을 조금 세우고 나서 실제로 계획이 얼마나 진척되었는지 정보를 모아서 새로운 계획을 세울 때 활용합니다.

- 계획은 쓸모 없지만 계획하기는 가장 중요하다.

- 프로젝트 위험목록 만들기 : 프로젝트 계획에 적어도 10대 위험목록을 작성하세요.

- 고객은 결함 개수가 적다고 제품을 구매하지 않습니다. 고객은 제품을 활용해서 자신이 해결하고 싶은 문제를 해결할 수 있기 때문에 구매합니다.

- 프로젝트 팀원, 후원자, 여러분을 위해 완료의 의미를 정의하는 출시 기준을 만드세요.

## 3. 생애주기를 사용해서 프로젝트 설계하기

- 고객 처지에서 가장 중요한 위험이 무엇인지 알아내야 합니다. 고객에게 가장 중요한 위험이 출시일이거나 결함, 기능, 비용이 되었든 이 위험을 최적화하는 생애주기를 선택하세요.

- 현실에서 어떤 단계가 끝나지 않아도 다음 단계를 시작하지만, 연속적 생애주기에서는 한 번에 하나의 단계만 존재한다는 심리적인 상태가 있습니다.

- 연속적 생애주기는 오래 걸립니다. 왜냐하면 기능을 구현하거나 결함을 발견해서 수정하거나 시스템 모듈을 통합하거나 요구사항 변경을 관리하는 데 얼마나 오래 걸릴지 예상할 수 있다고 가정하기 때문입니다.

- 애자일 생애주기는 조금 계획하고나서 프로젝트를 시작합니다. 즉 계획의 수준은 일을 시작하고 아울러 제품 소유자(product owner)가 이번 출시에서 끝내고 싶어하는 것이 무엇인지 알아내는 정도면 충분합니다.

- 애자일 생애주기의 경우 팀은 능동적으로 자신들이 수행한 작업과 작업 프로세스에 대한 피드백을 구하기 때문에, 프로젝트 상태에 대한 피드백, 개발속도, 결함을 발견하고 수정하는 속도, 팀에서 내리는 가정을 생애주기의 일부로서 인정합니다.

- 아키텍처 위험을 실제로 관리하는 유일한 방법은 무언가를 구현하고 테스트해 보는 것입니다.

- 연속적 생애주기를 따라야 한다면 다음을 따르시오.
- (1) 계획 작성하기, 요구사항, 프로토타이핑을 포함한 모든 것을 반복적으로 계획하세요
- (2) 능력이 되는 한 프로젝트를 시작할 때 가능한 많은 것을 고객이나 고객 대리인에게 보여주거나 프로토타입을 만들어서 보여주세요. 고객이나 고객 대리인에게서 피드백을 많이 받는다면 프로젝트의 상태가 더 좋아집니다.
- (3) 프로젝트를 시작하면서 테스트를 시작하세요. 시스템 전체를 사용하기 전부터 피드백을 얻기 위해서 테스터와 함께 작업하세요.
- (4) 프로젝트를 진행하면서 기능 단위로 구현하고 통합하고 테스트 하세요.
- (5) 문서를 반드시 고객에게 인도해야 한다면 (문서 인도는 연속적 생애주기의 각 단계 마지막에 있는 전형적인 마일스톤입니다), 문서만이 고객에게 인도해야 하는 유일한 산출물이 되지 않게 하세요. 고객과 함께 프로토타입을 살펴보고 고객에게 작동하는 제품을 넘겨주면 팀원들은 유용한 피드백을 얻을 겁니다.

- 스테이지 게이트나 폭포수 생애주기로 성공할 수 있다고 생각할 때만 이 생애주기를 사용하세요, 아무 생각 없이 이런 생애주기를 선택하지 마세요.

## 4. 프로젝트 일정잡기

- 계약서에 서명하기 전에 프로젝트 일정을 보고 싶어하는 고객과 일한다면 처음에 수립하는 일정은 최선을 다해 내놓은 예측치라는 사실을 정확하게 알려주세요. 이 일정은 변할 겁니다. 아울러 고객에게 예측에서 필요한 것은 정밀함(precision)이 아니라 정확함(accuracy)이다'란 걸 알려주세요.

- 일정잡기와 예측은 서로 다른 활동입니다. 일정잡기는 작업에 순서를 부여하고 작업 사이의 독립성을 보여주는 일이죠. 예측은 특정 작업을 처리하는 데 시간이 얼마나 걸릴지 추측하는 것입니다.

- 하향식 일정잡기: 일반적으로 마일슽노에서 시작합니다. 연속적 생애주기에선 하향식 일정잡기로 시작하는 경향이 있습니다. 단계가 매우 명확하기 때문입니다.

- 상향식 일정잡기: 상향식 일정잡기는 특정 작업에서 시작합니다. 

- 허드슨 만 시;작하기: 여러분들 포함한 팀원들이 예측하는 작업이 얼마나 걸릴지 잘 알지 못한다면 허드슨 만 시작 방법에 타임박스를 적용하세요. (...) 팀원들이 무언가를 만들어낸 다음 활동 내역을 간략하게 살펴봅니다. 

- 일정관리 소프트웨어를 사용하면 전체 팀원들이 일정잡기 활동에 적극적으로 참여하지 못합니다. 일정을 작성하려고 도구를 사용하면 토론을 줄이고 보이지 않는 의존관계와 위험을 노출하지 못합니다. (...) 팀원들에게 ㅣㄹ정에 대한 소유권이 있다면 일정을 지킬 것입니다. 프로젝트 관리자 일정을 소윻나다면 여러분은 작업 사이에 존재하는 상호의존성을 관리하는 게 아니라 팀원들을 깐깐히 관리하려고 들 겁니다.

- 마일스톤을 어정쩡하게 마무리 짓는 것을 피하려면 마일스톤을 끝내기 전에 작업을 정리하는 것을 계획하세요. (...) 모든 요구사항을 정리할 것을 '요구사항 확정' 마일스톤으로 구성합니다.

- 기능 조직에 따라서 일정을 수립하는 게 아니라 산출물 기준으로 일정을 세우세요.

## 5. 작업량 예측하기

- 예측치를 낮게 잡는 문제를 해결하는 방법은 에측하는 동안 규모(sizing)와 기간(duration)을 분리하는 것입니다.
- 작업에 포함된 시간 버퍼를 제거하세요. 팀원들에게 예측치에 버퍼를 추가했는지 확인하세요. 작업 시간을 줄이려는 게 아니라 가장 정확한 예측치를 얻으려고 물어보는 것임을 설명합니다.
- 가장 빠른 완료일이란 프로젝트가 끝날 것이라고 보장하지 못하는 첫째 날입니다.
- 여러분이 에측치를 늘리거나 아니면 버퍼나 오차를 추가함으로써 산출된 것이 끝낼 확률이 높은 완료일입니다.
- 최악의 완료일을 산출하려면 끝낼 확률이 높은 완료일에 오차를 더합니다.
- 정밀함(precision)은 측정의 엄밀함으로서 소수점 자리수를 뜻합니다. 정확함(Accuracy)은 예측치에 얼마나 가까운지를 나타냅니다. 일정잡기를 할 때 여러분이 고민하는 것이 바로 정확함이죠. 작업 기간이 일정을 얼마나 가깝게 에측했는지를 고민하지, 작업이 어떤 날 몇 시에 끝날지 프로젝트가 언제 끝날지 고민하지 않습니다. 
- 콘(Cohn)은 작업에 대한 개략적인 예측치를 작성하는 데 피보나치 수열을 사용할 것을 제안했습니다. 팀원들이 모든 작업을 규모 13보다 더 크게 예측했다면, 팀원들은 작업을 더 잘게 나누지 않은 셈입니다.
- 작업 규모가 크다는 것을 알지만 어느 정도 큰지 잘 모를 때가 있습니다. 이런 경우라면 스파이크를 사용하세요.
- 팀원들은 예측하는 방법을 연습하고 산출한 예측이 잘 되었는지 피드백을 받아야 합니다. 피드백이 없는 예측은 헛된 예측일 뿐입니다.
- 데드라인이 촉박하다면 예측하는 데 시간을 허비하지마세요.
- 마일스톤이나 반복주기를 주중에 끝나도록 일정을 잡는다면 끝내지 못한 작업량이 명확해집니다.
- 주요한 마일스톤이나 반복주기의 시작과 끝을 화요일이나 수요일로 정하세요
- 프로젝트 관리자는 흔히 '얼마나 적게' 라는 사고방식의 특징들이 중요하다고 말하지만, '얼마나 많이'라는 사고방식에 따라 관리합니다. 상위 관리자가 '얼마나 많이'라는 식으로 물어볼 때, 여러분은 '얼마나 적게'라는 방식으로 볼 수도 있습니다.
- 멀티태스킹 때문에 여러분이 관리하는 프로젝트는 반드시 지연될 겁니다.
- 고의적으로 팀원들을 멀티태스킹하도록 배치할 수 있습니다. 프로젝트 중간에 잠깐 필요한 팀원이 있다면, 주 단위로 프로젝트를 바꿔가면서 팀원을 할당합니다.
- 여러분이 잘 아는 것부터 상세하게 작업을 계획하세요. 그리고 그 이상으로 일정을 수립하려고 고생하지 마세요.
- 단번에 프로젝트 전체 일정을 상세하게 작성하려고 시도하는대신 포스트잇을 벽에 붙이면서 여러분이 언제 주요한 마일스톤을 달성하길 바라는지 팀원에게 알려주세요, 첫 번째 마일스톤에 대해서 이렇게 질문을 하세요. "이 마일스톤을 달성하려면 어떻게 해야 되죠?" 그러고 나서 프로젝트 팀원에게 팀원이 수행할 작업과 이 작업 사이에 존재하는 상호의존성을 포스트잇에 적게 하세요. 포스트잇 하나에는 작업 하나만을 적게 합니다.
- 반복주기의 기간을 4주보다 길어지는 것을 추천하지 ㅇ낳습니다. 팀원들이 학생 신드롬에 걸릴 가능성이 높아지고 (...) 지속적인 통합을 피하려고 합니다.
- 반복주기에서는 최소한의 기간이 필요합니다. 2일 안쪽으로 반복주기를 계획할 수 없다면 반복주기를 3주 안으로 작성하려고 노력하지 마세요,
- 인치페플에서 10퍼센트 완료 혹은 50퍼센트 완료처럼 어정쩡하게 완료를 표시하는 퍼센트 완료를 사용하지 않습니다. 
- 인치페블은 애자일 생애주기에서 일반적으로 사용합니다.
- 매일 혹은 주마다 계획하기를 하면서 인치페블을 사용하는 게 이치에 맞습니다. 즉 프로젝트 전체 계획을 수립하는 경우에는 적당하지 않습니다.
- 작업 내용을 제대로 파악했을 때 인치페블은 유용합니다.
- 팀원마다 인치페블을 정의하는 방법이 있습니다. 각 팀원은 프로젝트에 기여해야 하는 개인적인 책임이 있습니다. 프로젝트 관리자는 인치페블을 정의하지 않습니다. 
- 팀원들이 인치페블 작성 방법을 모를 때 팀원들을 코칭하는 것은 괜찮습니다.
- 여러분이 사용하는 생애주기가 훨씬 연속적이거나 작업이 길수록, 인치페블은 효과적입니다. 팀원들에게 인치페블을 사용해서 일정을 세우라고 지시하면 팀원들은 모두 작업과 작업 사이에 있는 상호 의존성을 이해합니다.
- 프로젝트 완료일로서 달력에 있는 특정 날짜를 알려주지 마세요
- 작업이 작아질수록, 작업을 예측하기 더 쉬워집니다.

## 6. 일정게임을 파악하고 막아내기

- 일정의 다시 작성하라고 할 경우: 무엇이 가장 중요한지 알아낸다면 합리적인 해결책을 알아낼 수 있습니다. / 후원자가 바라는 날짜에 어떤 이유가 있는지 알아보세요. / 여러분이 고른 선택사항과 그런 선택사항을 고른 이유를 후원자가 이해하게 하세요. / 여러분이 알려주는 완료일의 신뢰 범위를 설명해주세요.
- 현실부정의 관리자 : 다음의 접근방법을 프로젝트 관리에 넣어서 관련자들이 현실을 직시하도록 하세요. 타임박스를 적용한 반복주기를 사용하세요, 이렇게 하면 모든 사람들은 프로젝트 진척도를 확인할 수 있습니다. 우선순위가 매겨진 제품 백로그를 작성하세요. 백로그를 작성하면 팀은 가치가 높은 순서대로 기능을 구현할 수 있습니다. 후원자가 정신을 차려서 여러분이 불가능한 완료일을 달성하려고 시도한다는 것을 깨달았을 때, 팀원들이 우선순위대로 기능을 끝냈기 때문에 여러분은 쓸모 있는 결과물을 얻을 것입니다.
- 일정은 판결문이다 / 상위관리자가 확답을 요구할 때 제가 즐겨쓰는 방법은 신뢰수준을 사용해서 일정을 제공하는 것입니다.
- 제가 주로 사용하는 다른 방법은 날짜를 두고 이야기하는 방법입니다. "저는 올해 하반기 안에 출시될 것이라고 말씀드릴 수 있습니다 (특정한 날을 지목하면서) 이 시점이 되면 1분기 안으로 출시일을 좁힐 수 있습니다. (다른 날을 지목하면서) 이 시점에 1달 안으로 출시일을 좁힐 수 있고 (뒤에 날짜를 지목하면서) 이 날짜엔 최종 출시일을 알려드릴 수 있습니다. 

## 7. 탁월한 팀 만들기

- 팀원들이 뭉치기를 바란다면, 팀원들이 함께 성취할 수 있는 단기간의 목표를 설정하도록 도와주세요.
- 팀원들은 기능조직에도 속하고, 아울러 프로젝트 팀에도 속하죠. 이런 이유로 프로젝트 완료를 책임지는 프로젝트 관리자의 권한이 약해지고 작업도 지연되죠.
- 팀원들이 협력해서 일하게 하려면 회사 내 기능부서 관리자의 목록을 작성하세요. 팀원들이 기능부서 관리자를 위해서가 아닌 그들이 맡은 산출물을 위해 일하도록 팀원과 작업해야 합니다. 팀원들이 지켜야 할 첫째 책임은 기능조직의 관리자들의 말을 듣는 게 아니라 프로젝트를 수행하는 데 있다는 것을 기능조직의 관리자들이 이해하도록 도와야 합니다.
- 혼자서 9명 정도의 팀원을 관리할 수 있습니다. 팀원이 9명보다 많다면, 산출물에 따라서 기술 리더나 다른 프로젝트의 관리자가 필요합니다.
- 콕번은 9명이 넘는 팀에서 팀 내 역학이 바뀐다고 설명했습니다. 큰 규모의 팀은 상호 의존 관계가 높은 산출물을 만드는 팀들처럼 친밀하지 않습니다.

## 8. 프로젝트 조정하기

- 애자일 생애주기를 사용하지만 빠르고 경쾌한 리듬을 발견하지 못한다면 팀이 애자일 가치를 따르지 않거나 애자일 실천방법을 사용하지 않을 가능성이 높습니다.
- 애자일 생애 주기를 사용하는 프로젝트에서 반복주기가 끝낼 때마다 회고를 실시해야 합니다. 연속적인 생애주기나 반복적인 생애주기, 아니면 점진적인 생애 주기를 사용하는 프로젝트에서도 주요 마일스톤을 끝내고 나서 회고를 실시해야 합니다.
- 요구 사항에 순위 매기기, 즉 요구사항마다 1에서 번호를 하나씩 매기는 일은 팀원들이 무엇을 언제 구현할 것인지 파악하도록 도와줍니다. 기능 단위로 구현하지 않아도 번호가 붙은 순서대로 기능을 끝낼 수 있습니다.
- 기준: 기능의 아키텍처 수준에서 영향, 구현 시간을 예측한 값, 핵심 고객에게 이 기능이 얼마나 중요한가, 기능을 구현하고 테스트하는 데 특정한 인력을 할당할 수 있는가.
- 반드시 요구사항 단계를 밟아야 한다면 요구사항 단계에 타임박스를 적용하세요. 그렇지 않으면 요구사항 도출과 정의는 전체 프로젝트 기간을 허비할 정도로 늘어날 수 있습니다.
- 초기 요구사항에 타임박스를 적용하고 요구사항을 모으는 작업을 계속하기 : 이 방법을 사용해서 적당한 기간을 할당하고 나서( 프로젝트 전체 기간 가운데 10퍼센트 정도) 가장 중요한 요구사항을 달라고 요청합니다. 고객에게 가장 중요한 요구사항을 얻지만 이런 요구사항이 핵심적인 아키텍처 결정과 연계되지 않는 것은 위험합니다.
- 요구사항을 정의하는 모든 작업에 타임박스를 적용하기. "당신은 팀워크를 깨는 사람이군요" 라는 비평이나 말도 안되는 얘기를 들을 각오를 해야합니다.
- 프로젝트 규모를 작게 시작하고 계속해서 규모를 작게 유지합니다. 그리고 프로젝트 관리자들은 프로젝트 현실에 부합하는 반복주기, 타임박스나 증분을 사용합니다.
- 프로젝트 초반에 결함을 관리하는 작업을 시작하지 않는다면 결함이 여러분을 관리하게 될겁니다. 프로젝트에는 기술 빚이 쌓이고 있지만, 여러분은 프로젝트가 끝날 때까지 기술 빚이 존재하는 것을 눈치채지도 못할 것입니다. 결국 프로젝트 종료 시점에 가서 수정하지 못할 정도로 결함이 쌓이고, 결함을 모두 수정하지 못한 채 프로젝트가 끝납니다.


